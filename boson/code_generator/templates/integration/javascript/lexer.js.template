{% if configure.boson_option['code_comment'] == 'yes' -%}
/*
    {{ configure.boson_title }} - {{ configure.boson_description }}

        Author: {{ configure.boson_author }}
        Email:  {{ configure.boson_email }}
        Site:   {{ configure.boson_url }}

    File: "lexer.js"
    These codes ware generated by the boson JavaScript code generator.
*/

{% endif -%}
import { {{- configure.boson_option['token_class_name'] }}} from './token';

export class {{ configure.boson_option['lexer_class_name'] }} {
    constructor() {
        this._tokenList = [];
        this._line = {{ configure.boson_lexical_start_line }};
        this._errorIndex = {{ configure.boson_lexical_no_error_index }};
        this._noErrorIndex = {{ configure.boson_lexical_no_error_index }};
        this._skip = {{ 'true' if configure.boson_lexical_default_skip else 'false' }};
        {%- if configure.boson_option['lexer_compact_table'] == 'yes' %}
        this._compactMoveTable = {
            {%- for state, state_move_table in lexer.compact_move_table.items() %}
            {{ state }}: [
                {%- for compact_tuple in state_move_table %}
                [{{ compact_tuple[0] }}, new Set([{%- for character in compact_tuple[1] -%}
                    '{{ ('\\%s' if character == '\'' else '%s') % character.encode('unicode-escape').decode() }}'
                {%- if not loop.last %}, {% endif -%}
                {%- endfor -%}]), [{%- for range in compact_tuple[2] -%}
                    ['{{ ('\\%s' if range[0] == '\'' else '%s') % range[0].encode('unicode-escape').decode() }}', '{{ ('\\%s' if range[1] == '\'' else '%s') % range[1].encode('unicode-escape').decode() }}']
                {%- if not loop.last %}, {% endif -%}
                {%- endfor -%}], {{ compact_tuple[3] }}]
                {%- if not loop.last %},{% endif -%}
                {%- endfor %}
            ]
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        {%- else %}
        this._moveTable = {
            {%- for state, stateMoveTable in lexer.move_table.items() %}
            {{ state }}: [{{ stateMoveTable.get(True, -1) }}, {
                {%- for character, to_state in stateMoveTable.items() -%}
                {%- if character != True -%}
                '{{ ('\\%s' if character == '\'' else '%s') % character.encode('unicode-escape').decode() }}': {{ to_state }}
                {%- if not loop.last %}, {% endif -%}
                {%- endif -%}
                {%- endfor -%}
            }]
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        {%- endif %}
        this._characterSet = new Set([
            {%- for character in lexer.character_set -%}
                '{{ ('\\%s' if character == '\'' else '%s') % character.encode('unicode-escape').decode() }}'
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        ]);
        this._startState = {{ lexer.start_state }};
        this._endStateSet = new Set([
            {%- for state in lexer.end_state_set -%}
                {{ state }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        ]);
        this._lexicalSymbolMapping = {
            {%- for state, symbol in lexer.lexical_symbol_mapping.items() %}
            {{ state }}: '{{ symbol }}'
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        this._nonGreedyStateSet = new Set([
            {%- for state in lexer.non_greedy_state_set -%}
                {{ state }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        ]);
        this._symbolFunctionMapping = {
            {%- for symbol, function_list in lexer.symbol_function_mapping.items() %}
            '{{ symbol }}': [
                {%- for function in function_list -%}
                '{{ function }}'
                {%- if not loop.last %},{% endif -%}
                {%- endfor -%}
            ]
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        this._lexicalFunction = {};
    }

    tokenList() {
        return this._tokenList;
    }

    line() {
        return this._line;
    }

    skip() {
        this._skip = true;
    }

    newline() {
        this._line++;
    }

    errorIndex() {
        return this._errorIndex;
    }

    noErrorIndex() {
        return this._noErrorIndex;
    }

    tokenize(text) {
        this._tokenList = [];
        this._line = {{ configure.boson_lexical_start_line }};
        let state = this._startState;
        let tokenString = '';
        let index = 0;
        while (index < text.length) {
            const character = text[index];
            index++;
            let getToken = false;
            if (this._nonGreedyStateSet.has(state)) {
                getToken = true;
            }
            {%- if configure.boson_option['lexer_compact_table'] == 'yes' %}
            if (this._compactMoveTable.hasOwnProperty(state)) {
                const stateMoveTable = this._compactMoveTable[state];
                let i;
                for (i = 0; i < stateMoveTable.length; i++) {
                    const compactTable = stateMoveTable[i];
                    const attribute = compactTable[0];
                    const characterSet = compactTable[1];
                    const rangeList = compactTable[2];
                    const nextState = compactTable[3];
                    let condition = false;
                    if (attribute === 2) {
                        condition = !characterSet.has(character);
                        for (const index in rangeList) {
                            const range = rangeList[index];
                            condition &= character < range[0] || character > range[1];
                        }
                    } else {
                        condition = characterSet.has(character);
                        if (attribute === 1 && !this._characterSet.has(character)) {
                            condition = true;
                        }
                        for (const index in rangeList) {
                            const range = rangeList[index];
                            if (condition || (range[0] <= character && character <= range[1])) {
                                condition = true;
                                break;
                            }
                        }
                    }
                    if (condition) {
                        tokenString += character;
                        state = nextState;
                        break;
                    }
                }
                if (i === stateMoveTable.length) {
            {%- else %}
            if (this._moveTable.hasOwnProperty(state)) {
                let augmentedMoveTable = this._moveTable[state];
                let wildcard = augmentedMoveTable[0];
                let characterMoveTable = augmentedMoveTable[1];
                if (characterMoveTable.hasOwnProperty(character)) {
                    tokenString += character;
                    state = characterMoveTable[character];
                } else if (wildcard !== -1 && !this._characterSet.has(character)) {
                    tokenString += character;
                    state = wildcard;
                } else {
            {%- endif %}
                    if (this._endStateSet.has(state)) {
                        getToken = true;
                    } else {
                        this._errorIndex = index - 1;
                        return this._errorIndex;
                    }
                }
            } else {
                if (this._endStateSet.has(state)) {
                    getToken = true;
                } else {
                    this._errorIndex = index - 1;
                    return this._errorIndex;
                }
            }
            if (getToken) {
                this._generateToken(state, tokenString);
                tokenString = '';
                state = this._startState;
                index--;
            }
        }
        if (this._endStateSet.has(state)) {
            this._generateToken(state, tokenString);
        } else {
            this._errorIndex = index - 1;
            return this._errorIndex;
        }
        this._tokenList.push(new {{ configure.boson_option['token_class_name'] }}('', this._line, '{{ configure.boson_end_symbol }}'));
        return this._errorIndex;
    }

    registerFunction(functionName, functionObject) {
        this._lexicalFunction[functionName] = functionObject;
    }

    _invokeLexicalFunction(symbol, tokenString) {
        this._skip = {{ 'true' if configure.boson_lexical_default_skip else 'false' }};
        if (this._symbolFunctionMapping.hasOwnProperty(symbol)) {
            for (let functionName in this._symbolFunctionMapping[symbol]) {
                if (this._lexicalFunction.hasOwnProperty(functionName)) {
                    tokenString = this._lexicalFunction[functionName](tokenString);
                } else if (functionName === 'skip') {
                    this.skip();
                } else if (functionName === 'newline') {
                    this.newline();
                }
            }
        }
        return tokenString;
    }

    _generateToken(state, tokenString) {
        let symbol = null;
        if (this._lexicalSymbolMapping.hasOwnProperty) {
            symbol = this._lexicalSymbolMapping[state];
        } else {
            symbol = '{{ configure.boson_default_symbol }}';
        }
        tokenString = this._invokeLexicalFunction(symbol, tokenString);
        if (!this._skip) {
            this._tokenList.push(new {{ configure.boson_option['token_class_name'] }}(tokenString, this._line, symbol));
        }
    }
}

