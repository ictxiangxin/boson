{% if configure.boson_option['code_comment'] == 'yes' -%}
/*
    {{ configure.boson_title }} - {{ configure.boson_description }}

        Author: {{ configure.boson_author }}
        Email:  {{ configure.boson_email }}
        Site:   {{ configure.boson_url }}

    File: "parser.js"
    These codes ware generated by the boson JavaScript code generator.
*/

{% endif -%}
import { {{- configure.boson_option['grammar_class_name'] }}} from './grammar';
import { {{- configure.boson_option['grammar_node_class_name'] }}} from './grammar_node';

export class {{ configure.boson_option['parser_class_name'] }} {
    constructor() {
        this._terminalIndexMapping = {
            {%- for terminal, index in parser.terminal_index_mapping.items() %}
            '{{ terminal }}': {{ index }}
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        {%- if configure.boson_option['parser_sparse_table'] == 'yes' %}
        this._sparseActionTable = {
            {%- for i, sub_table in parser.sparse_action_table.items() %}
            {{ i }}: {
            {%- for j, each in sub_table.items() -%}
            {{ j }}: '{{ each }}'
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
            }
            {%- if not loop.last %}, {% endif -%}
            {%- endfor %}
        };
        this._sparseGotoTable = {
            {%- for i, sub_table in parser.sparse_goto_table.items() %}
            {{ i }}: {
            {%- for j, each in sub_table.items() -%}
            {{ j }}: {{ each }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
            }
            {%- if not loop.last %}, {% endif -%}
            {%- endfor %}
        };
        {%- else %}
        this._actionTable = [
            {%- for line in parser.action_table %}
            [
                {%- for each in line -%}
                '{{ each }}'
                {%- if not loop.last %}, {% endif -%}
                {%- endfor -%}
            ]
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        ];
        this._gotoTable = [
            {%- for line in parser.goto_table %}
            [
                {%- for each in line -%}
                {{ each }}
                {%- if not loop.last %}, {% endif -%}
                {%- endfor -%}
            ]
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        ];
        {%- endif %}
        this._sentenceIndexGrammarTupleMapping = {
            {%- for sentence_index, grammar_tuple in parser.sentence_index_grammar_tuple_mapping.items() %}
            {{ sentence_index }}: [
            {%- for node in grammar_tuple -%}
            '{{ node }}'
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
            ]
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        this._reduceSymbolCount = [
            {%- for count in parser.reduce_symbol_count -%}
            {{ count }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        ];
        this._reduceNonTerminalIndex = [
            {%- for index in parser.reduce_non_terminal_index -%}
            {{ index }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        ];
        this._noneGrammarTupleReduceSet = new Set([
            {%- for index in parser.none_grammar_tuple_sentence_index_set -%}
            {{ index }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        ]);
    }

    parse(tokenList) {
        let grammar = new {{ configure.boson_option['grammar_class_name'] }}();
        let analysisStack = [0];
        let symbolStack = [];
        let tokenIndex = 0;
        while (tokenIndex < tokenList.length) {
            const token = tokenList[tokenIndex];
            const currentState = analysisStack[analysisStack.length - 1];
            {%- if configure.boson_option['parser_sparse_table'] == 'yes' %}
            let operation = '{{ configure.boson_table_sign_error }}';
            const terminalIndex = this._terminalIndexMapping[token.symbol];
            if (this._sparseActionTable.hasOwnProperty(currentState)) {
                const actions = this._sparseActionTable[currentState];
                if (actions.hasOwnProperty(terminalIndex)) {
                    operation = actions[terminalIndex];
                }
            }
            {%- else %}
            operation = this._actionTable[currentState][this._terminalIndexMapping[token.symbol]];
            {%- endif %}
            const operationFlag = operation[0];
            if (operationFlag === '{{ configure.boson_table_sign_error }}') {
                grammar.setErrorIndex(tokenIndex);
                return grammar;
            } else if (operationFlag === '{{ configure.boson_table_sign_shift }}') {
                analysisStack.push(parseInt(operation.substring(1)));
                tokenIndex++;
                symbolStack.push(new {{ configure.boson_option['grammar_node_class_name'] }}(token.text));
            } else if (operationFlag === '{{ configure.boson_table_sign_reduce }}') {
                const statementIndex = parseInt(operation.substring(1));
                const reduceCount = this._reduceSymbolCount[statementIndex];
                for (let i = 0; i < reduceCount; i++) {
                    analysisStack.pop();
                }
                const currentState = analysisStack[analysisStack.length - 1];
                const currentNonTerminalIndexMapping = this._reduceNonTerminalIndex[statementIndex];
                {%- if configure.boson_option['parser_sparse_table'] == 'yes' %}
                let gotoNextState = -1;
                if (this._sparseGotoTable.hasOwnProperty(currentState)) {
                    const gotoTable = this._sparseGotoTable[currentState];
                    if (gotoTable.hasOwnProperty(currentNonTerminalIndexMapping)) {
                        gotoNextState = gotoTable[currentNonTerminalIndexMapping];
                    }
                }
                {%- else %}
                const gotoNextState = this._gotoTable[currentState][currentNonTerminalIndexMapping];
                {%- endif %}
                if (gotoNextState === {{ configure.boson_invalid_goto }}) {
                    throw 'Invalid goto action.';
                }
                analysisStack.push(gotoNextState);
                {%- if parser.sentence_index_grammar_tuple_mapping %}
                if (this._sentenceIndexGrammarTupleMapping.hasOwnProperty(statementIndex)) {
                    let symbolPackage = [];
                    for (let i = 0; i < reduceCount; i++) {
                        symbolPackage.splice(0, 0, symbolStack.pop());
                    }
                    let grammarNode = new {{ configure.boson_option['grammar_node_class_name'] }}();
                    for (const index in this._sentenceIndexGrammarTupleMapping[statementIndex]) {
                        const nodeString = this._sentenceIndexGrammarTupleMapping[statementIndex][index];
                        if (nodeString[0] === '{{ configure.boson_grammar_tuple_unpack }}') {
                            const reduceNumber = parseInt(nodeString.substring(1));
                            const packageChildren = symbolPackage[reduceNumber].children();
                            for (const index in packageChildren) {
                                grammarNode.append(packageChildren[index]);
                            }
                        } else {
                            grammarNode.append(symbolPackage[parseInt(nodeString)]);
                        }
                    }
                    grammarNode.setReduceNumber(statementIndex);
                    symbolStack.push(grammarNode);
                {%- endif %}
                {%- if parser.none_grammar_tuple_sentence_index_set %}
                {%- if parser.sentence_index_grammar_tuple_mapping %}
                } else if (this._noneGrammarTupleReduceSet.has(statementIndex)) {
                {%- else %}
                if (this._noneGrammarTupleReduceSet.has(statementIndex)) {
                {%- endif %}
                    let grammarNode = new {{ configure.boson_option['grammar_node_class_name'] }}();
                    for (let i = 0; i < reduceCount; i++) {
                        grammarNode.insert(0, symbolStack.pop());
                    }
                    grammarNode.setReduceNumber(statementIndex);
                    symbolStack.push(grammarNode);
                {%- endif %}
                {%- if parser.none_grammar_tuple_sentence_index_set or parser.none_grammar_tuple_sentence_index_set %}
                } else {
                    throw 'Invalid reduce number.';
                }
                {%- endif %}
            } else if (operationFlag === '{{ configure.boson_table_sign_accept }}') {
                grammar.setGrammarTree(symbolStack[symbolStack.length - 1]);
                return grammar;
            } else {
                throw 'Invalid action.';
            }
        }
        throw 'Analyzer unusual exit.';
    }
}

