{% if configure.boson_option['code_comment'] == 'yes' -%}
/*
    {{ configure.boson_title }} - {{ configure.boson_description }}

        Author: {{ configure.boson_author }}
        Email:  {{ configure.boson_email }}
        Site:   {{ configure.boson_url }}

    File: "{{ configure.boson_option['lexer_class_name'] }}.js"
    These codes ware generated by the boson Java code generator.
*/

{% endif -%}
import { {{- configure.boson_option['token_class_name'] }}} from './token';

export class {{ configure.boson_option['lexer_class_name'] }} {
    constructor() {
    }

    tokenList() {
        return this._tokenList;
    }

    skip() {
        this._skip = true;
    }

    newline() {
        this._line++;
    }

    errorIndex() {
        return this._errorIndex;
    }

    noErrorIndex() {
        return this._noErrorIndex;
    }

    tokenize(text) {
        this._tokenList = [];
        this._line = {{ configure.boson_lexical_start_line }};
        let state = this._startState;
        let index = 0;
        while (index < text.length()) {
            const character = text[index];
            index++;
            let getToken = false;
            if (this._nonGreedyStateSet.has(state)) {
                getToken = true;
            }
            {%- if configure.boson_option['lexer_compact_table'] == 'yes' %}
            if (this._compactMoveTable.hasOwnProperty(state)) {
                const stateMoveTable = this._compactMoveTable[state];
                let i;
                for (i = 0; i < stateMoveTable.length; i++) {
                    const compactTable = stateMoveTable[i];
                    const attribute = compactTable[0];
                    const characterSet = compactTable[1];
                    const rangeList = compactTable[2];
                    const nextState = compactTable[3];
                    let condition = false;
                    if (attribute === 2) {
                        condition = !characterSet.has(character);
                        for (let range in rangeList) {
                            condition &= character < range[0] || character > range[0];
                        }
                    } else {
                        condition = characterSet.has(character);
                        if (attribute === 1 && this._characterSet.has(character)) {
                            condition = true;
                        }
                        for (let range in rangeList) {
                            if (condition || (range[0] <= character && character <= range[0])) {
                                condition = true;
                                break;
                            }
                        }
                    }
                    if (condition) {
                        state = nextState;
                        break;
                    }
                }
                if (i === stateMoveTable.size()) {
            {%- else %}
            if (this._moveTable.hasOwnProperty(state)) {
                let augmentedMoveTable = this._moveTable[state];
                let wildcard = augmentedMoveTable[0];
                let characterMoveTable = augmentedMoveTable[1];
                if (characterMoveTable.hasOwnProperty(character)) {
                    state = characterMoveTable[character];
                } else if (wildcard !== -1 && !this._characterSet.has(character)) {
                    state = wildcard;
                } else {
            {%- endif %}
                    if (this._endStateSet.has(state)) {
                        getToken = true;
                    } else {
                        this._errorIndex = this._line;
                        return this._errorIndex;
                    }
                }
            } else {
                if (this._endStateSet.has(state)) {
                    getToken = true;
                } else {
                    this._errorIndex = this._line;
                    return this._errorIndex;
                }
            }
            if (getToken) {
                this._generateToken(state);
                state = this._startState;
                index--;
            }
        }
        if (this._endStateSet.has(state)) {
            this._generateToken(state);
        } else {
            throw 'Invalid state.';
        }
        this._tokenList.push(new {{ configure.boson_option['token_class_name'] }}('', this._line, '{{ configure.boson_end_symbol }}'));
        return this._errorIndex;
    }

    registerFunction(functionName, functionObject) {
        this._lexicalFunction[functionName] = functionObject;
    }

    _tokenList = [];
    _line = {{ configure.boson_lexical_start_line }};
    _errorIndex = {{ configure.boson_lexical_no_error_index }};
    _noErrorIndex = {{ configure.boson_lexical_no_error_index }};
    _skip = {{ 'true' if configure.boson_lexical_default_skip else 'false' }};
    {%- if configure.boson_option['lexer_compact_table'] == 'yes' %}
    _compactMoveTable = {
        {%- for state, stateMoveTable in lexer.compact_move_table.items() %}
        {{ state }}: [
            {%- for each in stateMoveTable %}
            [{{ each[0] }}, new Set([{%- for character in each[1] -%}
                '{{ '0x%s' % character.encode().hex() }}'
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}]), [{%- for character_range in each[2] -%}
                ['{{ '0x%s' % character_range[0].encode().hex() }}', '{{ '0x%s' % character_range[1].encode().hex() }}']
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}], {{ each[3] }}]
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        ]
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };
    {%- else %}
    _moveTable = {
        {%- for state, stateMoveTable in lexer.move_table.items() %}
        {{ state }}: [{{ stateMoveTable.get(True, -1) }}, {
            {%- for character, to_state in stateMoveTable.items() -%}
            {%- if character != True -%}
            '{{ '0x%s' % character.encode().hex() }}': {{ to_state }}
            {%- if not loop.last %}, {% endif -%}
            {%- endif -%}
            {%- endfor -%}
        }]
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };
    {%- endif %}
    _characterSet = new Set([
        {%- for character in lexer.character_set -%}
            '{{ '0x%s' % character.encode().hex() }}'
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
    ]);
    _startState = {{ lexer.start_state }};
    _endStateSet = new Set([
        {%- for state in lexer.end_state_set -%}
            {{ state }}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
    ]);
    _lexicalSymbolMapping = {
        {%- for state, symbol in lexer.lexical_symbol_mapping.items() %}
        {{ state }}: '{{ symbol }}'
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };
    _nonGreedyStateSet = new Set([
        {%- for state in lexer.non_greedy_state_set -%}
            {{ state }}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
    ]);
    _symbol_function_mapping = {
        {%- for symbol, function_list in lexer.symbol_function_mapping.items() %}
        '{{ symbol }}': [
            {%- for function in function_list -%}
            '{{ function }}'
            {%- if not loop.last %},{% endif -%}
            {%- endfor -%}
        ]
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };
    _lexicalFunction = {};

    _invokeLexicalFunction(symbol) {
        this._skip = {{ 'true' if configure.boson_lexical_default_skip else 'false' }};
        if (this._symbol_function_mapping.hasOwnProperty(symbol)) {
            for (let functionName in this._symbol_function_mapping[symbol]) {
                if (this._lexicalFunction.hasOwnProperty(functionName)) {
                    this._lexicalFunction[functionName](symbol);
                } else if (functionName === 'skip') {
                    this.skip();
                }
            }
        }
    }

    _generateToken(state) {
        let symbol = null;
        if (this._lexicalSymbolMapping.hasOwnProperty) {
            symbol = this._lexicalSymbolMapping[state];
        } else {
            symbol = '{{ configure.boson_default_symbol }}';
        }
        this._invokeLexicalFunction(symbol);
        if (!this._skip) {
            this._tokenList.push(new {{ configure.boson_option['token_class_name'] }}(symbol));
        }
    }
}

