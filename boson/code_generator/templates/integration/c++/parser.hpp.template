{% if boson_code_option['generator']['comment'] == 'True' -%}
/*
    {{ configure.boson_title }} - {{ configure.boson_description }}

        Author: {{ configure.boson_author }}
        Email:  {{ configure.boson_email }}
        Site:   {{ configure.boson_url }}

    File: "parser.hpp"
    These codes ware generated by the boson C++ code generator.
*/

{% endif -%}
#ifndef _BOSON_PARSER_HPP_
#define _BOSON_PARSER_HPP_

#include <vector>
#include <stack>
#include <set>
#include <unordered_map>
#include "token.hpp"
#include "grammar.hpp"
#include "grammar_node.hpp"

namespace boson {
    class {{ boson_code_option['class_name']['parser'] }} {
    public:
        {{ boson_code_option['class_name']['parser'] }}() = default;

        {{ boson_code_option['class_name']['grammar'] }} parse(std::vector<{{ boson_code_option['class_name']['token'] }}> token_list) {
            {{ boson_code_option['class_name']['grammar'] }} grammar;
            std::stack<int> analysis_stack;
            std::stack<{{ boson_code_option['class_name']['grammar_node'] }}> symbol_stack;
            analysis_stack.push(0);
            int token_index = 0;
            while (token_index < token_list.size()) {
                {{ boson_code_option['class_name']['token'] }} &token = token_list[token_index];
                int current_state = analysis_stack.top();
                std::string operation = "{{ configure.boson_table_sign_error }}";
                if (this->_terminal_index_mapping.count(token.symbol)) {
                {%- if boson_code_option['parser']['sparse_table'] == 'True' %}
                    int terminal_index = this->_terminal_index_mapping[token.symbol];
                    if (this->_sparse_action_table.count(current_state)) {
                        std::unordered_map<int, std::string> &actions = this->_sparse_action_table[current_state];
                        if (actions.count(terminal_index)) {
                            operation = actions[terminal_index];
                        }
                    }
                {%- else %}
                    operation = this->_action_table[current_state][this->_terminal_index_mapping[token.symbol]];
                {%- endif %}
                }
                char operation_flag = operation[0];
                if (operation_flag == '{{ configure.boson_table_sign_error }}') {
                    grammar.set_error_index(token_index);
                    return grammar;
                } else if (operation_flag == '{{ configure.boson_table_sign_shift }}') {
                    int state_number = (int) strtol(operation.c_str() + 1, nullptr, 10);
                    analysis_stack.push(state_number);
                    token_index++;
                    {{ boson_code_option['class_name']['grammar_node'] }} grammar_node(token.text);
                    symbol_stack.push(grammar_node);
                } else if (operation_flag == '{{ configure.boson_table_sign_reduce }}') {
                    int statement_index = (int) strtol(operation.c_str() + 1, nullptr, 10);
                    int reduce_count = this->_reduce_symbol_count[statement_index];
                    for (int i = 0; i < reduce_count; i++) {
                        analysis_stack.pop();
                    }
                    current_state = analysis_stack.top();
                    int current_non_terminal_index_mapping = this->_reduce_non_terminal_index[statement_index];
                    {%- if boson_code_option['parser']['sparse_table'] == 'True' %}
                    int goto_next_state = -1;
                    if (this->_sparse_goto_table.count(current_state)) {
                        std::unordered_map<int, int> &goto_table = this->_sparse_goto_table[current_state];
                        if (goto_table.count(current_non_terminal_index_mapping)) {
                            goto_next_state = goto_table[current_non_terminal_index_mapping];
                        }
                    }
                    {%- else %}
                    int goto_next_state = this->_goto_table[current_state][current_non_terminal_index_mapping];
                    {%- endif %}
                    if (goto_next_state == {{ configure.boson_invalid_goto }}) {
                        throw std::runtime_error("Invalid goto action.");
                    }
                    analysis_stack.push(goto_next_state);
                    {%- if parser.sentence_index_grammar_tuple_mapping %}
                    if (this->_sentence_index_grammar_tuple_mapping.count(statement_index)) {
                        std::vector<{{ boson_code_option['class_name']['grammar_node'] }}> symbol_package{};
                        for (int i = 0; i < reduce_count; i++) {
                            symbol_package.insert(symbol_package.begin(), symbol_stack.top());
                            symbol_stack.pop();
                        }
                        {{ boson_code_option['class_name']['grammar_node'] }} grammar_node;
                        for (std::string &node_string : this->_sentence_index_grammar_tuple_mapping[statement_index]) {
                            if (node_string[0] == '{{ configure.boson_grammar_tuple_unpack }}') {
                                int reduce_number = (int) strtol(node_string.c_str() + 1, nullptr, 10);
                                for ({{ boson_code_option['class_name']['grammar_node'] }} &node : symbol_package[reduce_number].children()) {
                                    grammar_node.append(node);
                                }
                            } else {
                                int reduce_number = (int) strtol(node_string.c_str(), nullptr, 10);
                                grammar_node.append(symbol_package[reduce_number]);
                            }
                        }
                        grammar_node.set_reduce_number(statement_index);
                        symbol_stack.push(grammar_node);
                    {%- endif %}
                    {%- if parser.none_grammar_tuple_sentence_index_set %}
                    {%- if parser.sentence_index_grammar_tuple_mapping %}
                    } else if (this->_non_grammar_tuple_reduce_set.count(statement_index)) {
                    {%- else %}
                    if (this->_non_grammar_tuple_reduce_set.count(statement_index)) {
                    {%- endif %}
                        {{ boson_code_option['class_name']['grammar_node'] }} grammar_node;
                        for (int i = 0; i < reduce_count; i++) {
                            grammar_node.insert(0, symbol_stack.top());
                            symbol_stack.pop();
                        }
                        grammar_node.set_reduce_number(statement_index);
                        symbol_stack.push(grammar_node);
                    {%- endif %}
                    {%- if parser.none_grammar_tuple_sentence_index_set or parser.none_grammar_tuple_sentence_index_set %}
                    } else {
                        throw std::runtime_error("Invalid reduce number.");
                    }
                    {%- endif %}
                } else if (operation_flag == '{{ configure.boson_table_sign_accept }}') {
                    grammar.set_grammar_tree(symbol_stack.top());
                    return grammar;
                } else {
                    throw std::runtime_error("Invalid action.");
                }
            }
            throw std::runtime_error("Analyzer unusual exit.");
        }

    private:
        std::unordered_map<std::string, int> _terminal_index_mapping = {
            {%- for terminal, index in parser.terminal_index_mapping.items() %}
            {"{{ terminal }}", {{ index -}} }
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        {%- if boson_code_option['parser']['sparse_table'] == 'True' %}
        std::unordered_map<int, std::unordered_map<int, std::string>> _sparse_action_table = {
            {%- for i, sub_table in parser.sparse_action_table.items() %}
            { {{- i }}, {
            {%- for j, each in sub_table.items() -%}
            { {{- j }}, "{{ each }}"}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
            }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor %}
        };
        std::unordered_map<int, std::unordered_map<int, int>> _sparse_goto_table = {
            {%- for i, sub_table in parser.sparse_goto_table.items() %}
            { {{- i }}, {
            {%- for j, each in sub_table.items() -%}
            { {{- j }}, {{ each -}} }
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
            }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor %}
        };
        {%- else %}
        std::vector<std::vector<std::string>> _action_table = {
            {%- for line in parser.action_table %}
            {
                {%- for each in line -%}
                "{{ each }}"
                {%- if not loop.last %}, {% endif -%}
                {%- endfor -%}
            }
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        std::vector<std::vector<int>> _goto_table = {
            {%- for line in parser.goto_table %}
            {
                {%- for each in line -%}
                {{ each }}
                {%- if not loop.last %}, {% endif -%}
                {%- endfor -%}
            }
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        {%- endif %}
        std::unordered_map<int, std::vector<std::string>> _sentence_index_grammar_tuple_mapping = {
            {%- for sentence_index, grammar_tuple in parser.sentence_index_grammar_tuple_mapping.items() %}
            { {{- sentence_index }}, {
            {%- for node in grammar_tuple -%}
            "{{ node }}"
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
            }}
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        std::vector<int> _reduce_symbol_count = {
            {%- for count in parser.reduce_symbol_count -%}
            {{ count }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        };
        std::vector<int> _reduce_non_terminal_index = {
            {%- for index in parser.reduce_non_terminal_index -%}
            {{ index }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        };
        std::set<int> _non_grammar_tuple_reduce_set = {
            {%- for index in parser.none_grammar_tuple_sentence_index_set -%}
            {{ index }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        };
    };
}

#endif

