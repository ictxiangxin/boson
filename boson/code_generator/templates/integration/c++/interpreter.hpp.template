{% if configure.boson_option['code_comment'] == 'yes' -%}
/*
    {{ configure.boson_title }} - {{ configure.boson_description }}

        Author: {{ configure.boson_author }}
        Email:  {{ configure.boson_email }}
        Site:   {{ configure.boson_url }}

    File: "interpreter.hpp"
    These codes ware generated by the boson C++ code generator.
*/

{% endif -%}
#ifndef _BOSON_INTERPRETER_HPP_
#define _BOSON_INTERPRETER_HPP_

#include <functional>
#include <vector>
#include <set>
#include <unordered_map>
#include "semantic_node.hpp"
#include "grammar_node.hpp"

namespace boson {
    template <class T>
    class {{ configure.boson_option['interpreter_class_name'] }} {
    public:
        using semantic_function = std::function<{{ configure.boson_option['semantic_node_class_name'] }}<T>({{ configure.boson_option['semantic_node_class_name'] }}<T> &)>;

        {{ configure.boson_option['interpreter_class_name'] }}() = default;

        {{ configure.boson_option['semantic_node_class_name'] }}<T> execute({{ configure.boson_option['grammar_node_class_name'] }} &grammar_tree) {
            return this->_semantics_analysis(grammar_tree);
        }

        void register_action(const char *reduce_name, semantic_function function) {
            std::string reduce_name_string(reduce_name);
            this->register_action(reduce_name_string, function);
        }

        void register_action(std::string &reduce_name, semantic_function function) {
            this->_semantic_action_mapping[reduce_name] = function;
        }

    private:
        std::unordered_map<int, std::string> _reduce_number_grammar_name_mapping = {
            {%- for reduce_number, grammar_name in parser.reduce_number_grammar_name_mapping.items() %}
            { {{- reduce_number }}, "{{ grammar_name }}"}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor %}
        };
        std::set<int> _naive_reduce_number_set = {
            {%- for reduce_number in parser.naive_reduce_number_set -%}
            {{ reduce_number }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        };
        std::unordered_map<std::string, semantic_function> _semantic_action_mapping{};

        {{ configure.boson_option['semantic_node_class_name'] }}<T> _semantics_analysis({{ configure.boson_option['grammar_node_class_name'] }} &grammar_tree) {
            std::string grammar_name{};
            if (this->_reduce_number_grammar_name_mapping.count(grammar_tree.get_reduce_number())) {
                grammar_name = this->_reduce_number_grammar_name_mapping[grammar_tree.get_reduce_number()];
            } else {
                grammar_name = "{{ configure.boson_grammar_name_prefix }}hidden";
            }
            {{ configure.boson_option['semantic_node_class_name'] }}<T> semantics_node;
            for (auto &node: grammar_tree.children()) {
                if (!node.children().empty()) {
                    semantics_node.append(this->_semantics_analysis(node));
                } else {
                    {{ configure.boson_option['semantic_node_class_name'] }}<T> temp_node;
                    temp_node.set_reduce_number(node.get_reduce_number());
                    temp_node.set_text(node.get_text());
                    semantics_node.append(temp_node);
                }
            }
            if (this->_semantic_action_mapping.count(grammar_name)) {
                return this->_semantic_action_mapping[grammar_name](semantics_node);
            } else if (this->_naive_reduce_number_set.count(grammar_tree.get_reduce_number())) {
                if (semantics_node.children().size() == 1) {
                    return semantics_node[0];
                } else {
                    return semantics_node;
                }
            } else {
                return semantics_node;
            }
        }
    };
}

#endif

