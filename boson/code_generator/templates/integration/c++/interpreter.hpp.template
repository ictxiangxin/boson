{% if boson_code_option['generator']['comment'] == 'True' -%}
/*
    {{ configure.boson_title }} - {{ configure.boson_description }}

        Author: {{ configure.boson_author }}
        Email:  {{ configure.boson_email }}
        Site:   {{ configure.boson_url }}

    File: "interpreter.hpp"
    These codes ware generated by the boson C++ code generator.
*/

{% endif -%}
#ifndef _BOSON_INTERPRETER_HPP_
#define _BOSON_INTERPRETER_HPP_

#include <functional>
#include <vector>
#include <set>
#include <unordered_map>
#include "semantic_node.hpp"
#include "grammar_node.hpp"

namespace boson {
    template <class T>
    class {{ boson_code_option['class_name']['interpreter'] }} {
    public:
        using semantic_function = std::function<{{ boson_code_option['class_name']['semantic_node'] }}<T>({{ boson_code_option['class_name']['semantic_node'] }}<T> &)>;

        {{ boson_code_option['class_name']['interpreter'] }}() = default;

        {{ boson_code_option['class_name']['semantic_node'] }}<T> execute({{ boson_code_option['class_name']['grammar_node'] }} &grammar_tree) {
            return this->_semantics_analysis(grammar_tree);
        }

        void register_action(const char *reduce_name, semantic_function function) {
            std::string reduce_name_string(reduce_name);
            this->register_action(reduce_name_string, function);
        }

        void register_action(std::string &reduce_name, semantic_function function) {
            this->_semantic_action_mapping[reduce_name] = function;
        }

    private:
        std::unordered_map<int, std::string> _reduce_number_grammar_name_mapping = {
            {%- for reduce_number, grammar_name in parser.reduce_number_grammar_name_mapping.items() %}
            { {{- reduce_number }}, "{{ grammar_name }}"}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor %}
        };
        std::set<int> _naive_reduce_number_set = {
            {%- for reduce_number in parser.naive_reduce_number_set -%}
            {{ reduce_number }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        };
        std::unordered_map<std::string, semantic_function> _semantic_action_mapping{};

        {{ boson_code_option['class_name']['semantic_node'] }}<T> _semantics_analysis({{ boson_code_option['class_name']['grammar_node'] }} &grammar_tree) {
            std::string grammar_name{};
            if (this->_reduce_number_grammar_name_mapping.count(grammar_tree.get_reduce_number())) {
                grammar_name = this->_reduce_number_grammar_name_mapping[grammar_tree.get_reduce_number()];
            } else {
                grammar_name = "{{ configure.boson_grammar_name_prefix }}hidden";
            }
            {{ boson_code_option['class_name']['semantic_node'] }}<T> semantic_node;
            if (grammar_tree.children().empty()) {
                semantic_node.set_reduce_number(grammar_tree.get_reduce_number());
                semantic_node.set_text(grammar_tree.get_text());
            } else {
                for (auto &grammar_node: grammar_tree.children()) {
                    semantic_node.append(this->_semantics_analysis(grammar_node));
                }
            }
            if (this->_semantic_action_mapping.count(grammar_name)) {
                return this->_semantic_action_mapping[grammar_name](semantic_node);
            } else if (this->_naive_reduce_number_set.count(grammar_tree.get_reduce_number())) {
                if (semantic_node.children().empty()) {
                    return {{ boson_code_option['class_name']['semantic_node'] }}<T>::null_node();
                } else if (semantic_node.children().size() == 1) {
                    return semantic_node[0];
                } else {
                    return semantic_node;
                }
            } else {
                return semantic_node;
            }
        }
    };
}

#endif

