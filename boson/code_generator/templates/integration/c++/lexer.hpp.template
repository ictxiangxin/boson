{% if configure.boson_option['code_comment'] == 'yes' -%}
/*
    {{ configure.boson_title }} - {{ configure.boson_description }}

        Author: {{ configure.boson_author }}
        Email:  {{ configure.boson_email }}
        Site:   {{ configure.boson_url }}

    File: "lexer.hpp"
    These codes ware generated by the boson C++ code generator.
*/

{% endif -%}
#ifndef _BOSON_LEXER_HPP_
#define _BOSON_LEXER_HPP_

#include <functional>
#include <vector>
#include <set>
#include <unordered_map>
#include "token.hpp"

namespace boson {
    class {{ configure.boson_option['lexer_class_name'] }} {
    public:
        using lexical_function = std::function<string_t &(string_t &)>;

        {{ configure.boson_option['lexer_class_name'] }}() = default;

        std::vector<{{ configure.boson_option['token_class_name'] }}> &token_list() {
            return this->_token_list;
        }

        int line() const {
            this->_line;
        }

        void skip() {
            this->_skip = true;
        }

        void newline() {
            this->_line++;
        }

        int error_index() const {
            return _error_index;
        }

        int no_error_index() const {
            return _no_error_index;
        }

        int tokenize(string_t text) {
            this->_token_list.clear();
            this->_line = {{ configure.boson_lexical_start_line }};
            int state = this->_start_state;
            string_t token_string{};
            int index = 0;
            while (index < text.length()) {
                char_t character = text[index];
                index++;
                bool get_token = false;
                if (this->_non_greedy_state_set.count(state)) {
                    get_token = true;
                }
                {%- if configure.boson_option['lexer_compact_table'] == 'yes' %}
                if (this->_compact_move_table.count(state)) {
                    std::vector<std::tuple<int, std::set<char_t>, std::vector<std::tuple<char_t, char_t>>, int>> state_move_table = this->_compact_move_table[state];
                    unsigned long i;
                    for (i = 0; i < state_move_table.size(); i++) {
                        std::tuple<int, std::set<char_t>, std::vector<std::tuple<char_t, char_t>>, int> compact_table = state_move_table[i];
                        int attribute = std::get<0>(compact_table);
                        std::set<char_t> &character_set = std::get<1>(compact_table);
                        std::vector<std::tuple<char_t, char_t>> &range_list = std::get<2>(compact_table);
                        int next_state = std::get<3>(compact_table);
                        bool condition;
                        if (attribute == 2) {
                            condition = !character_set.count(character);
                            for (auto & range : range_list) {
                                condition &= character < std::get<0>(range) || character > std::get<1>(range);
                            }
                        } else {
                            condition = character_set.count(character);
                            if (attribute == 1 && this->_character_set.count(character) == 0) {
                                condition = true;
                            }
                            for (auto & range : range_list) {
                                if (condition || (std::get<0>(range) <= character && character <= std::get<1>(range))) {
                                    condition = true;
                                    break;
                                }
                            }
                        }
                        if (condition) {
                            token_string += character;
                            state = next_state;
                            break;
                        }
                    }
                    if (i == state_move_table.size()) {
                {%- else %}
                if (this->_move_table.count(state)) {
                    std::tuple<int, std::unordered_map<char_t, int>> augmented_move_table = this->_move_table[state];
                    int wildcard = std::get<0>(augmented_move_table);
                    std::unordered_map<char_t, int> character_move_table = std::get<1>(augmented_move_table);
                    if (character_move_table.count(character)) {
                        token_string += character;
                        state = character_move_table[character];
                    } else if (wildcard != -1 && !this->_character_set.count(character)) {
                        token_string += character;
                        state = wildcard;
                    } else {
                {%- endif %}
                        if (this->_end_state_set.count(state)) {
                            get_token = true;
                        } else {
                            this->_error_index = index - 1;
                            return this->_error_index;
                        }
                    }
                } else {
                    if (this->_end_state_set.count(state)) {
                        get_token = true;
                    } else {
                        this->_error_index = index - 1;
                        return this->_error_index;
                    }
                }
                if (get_token) {
                    this->_generate_token(state, token_string);
                    token_string = "";
                    state = this->_start_state;
                    index--;
                }
            }
            if (this->_end_state_set.count(state)) {
                this->_generate_token(state, token_string);
            } else {
                this->_error_index = index - 1;
                return this->_error_index;
            }
            this->_token_list.emplace_back("", this->_line, "{{ configure.boson_end_symbol }}");
            return this->_error_index;
        }

        void register_function(std::string &function_name, lexical_function &function) {
            this->_lexical_function[function_name] = function;
        }

    private:
        std::vector<{{ configure.boson_option['token_class_name'] }}> _token_list{};
        int _line = {{ configure.boson_lexical_start_line }};
        int _error_index = {{ configure.boson_lexical_no_error_index }};
        int _no_error_index = {{ configure.boson_lexical_no_error_index }};
        bool _skip = {{ 'true' if configure.boson_lexical_default_skip else 'false' }};
        {%- if configure.boson_option['lexer_compact_table'] == 'yes' %}
        std::unordered_map<int, std::vector<std::tuple<int, std::set<char_t>, std::vector<std::tuple<char_t, char_t>>, int>>> _compact_move_table = {
            {%- for state, state_move_table in lexer.compact_move_table.items() %}
            { {{- state }}, {
                {%- for compact_tuple in state_move_table %}
                { {{- compact_tuple[0] }}, { {%- for character in each[1] -%}
                    '{{ ('\\%s' if character == '\'' else '%s') % character.encode('unicode-escape').decode() }}'
                {%- if not loop.last %}, {% endif -%}
                {%- endfor -%}}, { {%- for range in compact_tuple[2] -%}
                    {'{{ ('\\%s' if range[0] == '\'' else '%s') % range[0].encode('unicode-escape').decode() }}', '{{ ('\\%s' if range[1] == '\'' else '%s') % range[1].encode('unicode-escape').decode() }}'}
                {%- if not loop.last %}, {% endif -%}
                {%- endfor -%}}, {{ compact_tuple[3] }}}
                {%- if not loop.last %},{% endif -%}
                {%- endfor %}
            }}
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        {%- else %}
        std::unordered_map<int, std::tuple<int, std::unordered_map<char_t, int>>> _move_table = {
            {%- for state, state_move_table in lexer.move_table.items() %}
            { {{- state }}, { {{- state_move_table.get(True, -1) }}, {
                {%- for character, to_state in state_move_table.items() -%}
                {%- if character != True -%}
                {'{{ ('\\%s' if character == '\'' else '%s') % character.encode('unicode-escape').decode() }}', {{ to_state }}}
                {%- if not loop.last %}, {% endif -%}
                {%- endif -%}
                {%- endfor -%}
            }}}
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        {%- endif %}
        std::set<char_t> _character_set = {
            {%- for character in lexer.character_set -%}
                '{{ ('\\%s' if character == '\'' else '%s') % character.encode('unicode-escape').decode() }}'
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        };
        int _start_state = {{ lexer.start_state }};
        std::set<int> _end_state_set = {
            {%- for state in lexer.end_state_set -%}
                {{ state }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        };
        std::unordered_map<int, std::string> _lexical_symbol_mapping = {
            {%- for state, symbol in lexer.lexical_symbol_mapping.items() %}
            { {{- state }}, "{{ symbol }}"}
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        std::set<int> _non_greedy_state_set = {
            {%- for state in lexer.non_greedy_state_set -%}
                {{ state }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        };
        std::unordered_map<std::string, std::vector<std::string>> _symbol_function_mapping = {
            {%- for symbol, function_list in lexer.symbol_function_mapping.items() %}
            {"{{ symbol }}", {
                {%- for function in function_list -%}
                "{{ function }}"
                {%- if not loop.last %},{% endif -%}
                {%- endfor -%}
            }}
            {%- if not loop.last %},{% endif -%}
            {%- endfor %}
        };
        std::unordered_map<std::string, lexical_function> _lexical_function{};

        string_t &_invoke_lexical_function(std::string &symbol, string_t &token_string) {
            this->_skip = {{ 'true' if configure.boson_lexical_default_skip else 'false' }};
            if (this->_symbol_function_mapping.count(symbol)) {
                for (const auto& function : this->_symbol_function_mapping[symbol]) {
                    if (this->_lexical_function.count(function)) {
                        token_string = this->_lexical_function[function](token_string);
                    } else if (function == "skip") {
                        this->skip();
                    } else if (function == "newline") {
                        this->newline();
                    }
                }
            }
            return token_string;
        }

        void _generate_token(int state, string_t &token_string) {
            std::string symbol;
            if (this->_lexical_symbol_mapping.count(state)) {
                symbol = this->_lexical_symbol_mapping[state];
            } else {
                symbol = "{{ configure.boson_default_symbol }}";
            }
            token_string = this->_invoke_lexical_function(symbol, token_string);
            if (!this->_skip) {
                this->_token_list.emplace_back(token_string, this->_line, symbol);
            }
        }
    };
}

#endif

