{% if code_comment -%}
/*
    {{ configure.boson_title }} - {{ configure.boson_description }}

        Author: {{ configure.boson_author }}
        Email:  {{ configure.boson_email }}
        Site:   {{ configure.boson_url }}

    These codes are generated by the boson C++ code generator.
        {% for sentence in analyzer_table.sentence_list %}
        {{ ('%%%dd' % reduce_number_width) % loop.index0 }}: {{ sentence[0] }} -> {% for element in sentence[1:] -%}
                                                                                  {%- if element in grammar_package.literal_reverse_map -%}
                                                                                  '{{ grammar_package.literal_reverse_map[element] }}'
                                                                                  {%- else -%}
                                                                                  {{ element }}
                                                                                  {%- endif -%}
                                                                                  {%- if not loop.last %} {% endif -%}
                                                                                  {%- endfor -%}
        {%- endfor %}
*/


{% endif -%}
#include <stack>
#include <vector>
#include <set>
#include <unordered_map>
#include <string>
#include <functional>


class {{ configure.boson_option['lexical_token_class_name'] }} {
public:
    {{ configure.boson_option['lexical_token_class_name'] }}() = default;

    {{ configure.boson_option['lexical_token_class_name'] }}(std::string &text, const int line, std::string &symbol): text(text), line(line), symbol(symbol) {};

    {{ configure.boson_option['lexical_token_class_name'] }}(const char *text, const int line, const char *symbol): text(text), line(line), symbol(symbol) {};

    {{ configure.boson_option['lexical_token_class_name'] }}(const char *text, const int line, std::string &symbol): text(text), line(line), symbol(symbol) {};

    {{ configure.boson_option['lexical_token_class_name'] }}(std::string &text, const int line, const char *symbol): text(text), line(line), symbol(symbol) {};

    std::string text;
    int line = -1;
    std::string symbol;
};


{% if generate_lexical_analyzer -%}
class {{ configure.boson_option['lexical_analyzer_class_name'] }} {
public:
    using lexical_function = std::function<bool(std::string &)>;

    {{ configure.boson_option['lexical_analyzer_class_name'] }}() = default;

    std::vector<{{ configure.boson_option['lexical_token_class_name'] }}> &token_list() {
        return this->__token_list;
    }

    int error_line() {
        return __error_line;
    }

    int no_error_line() {
        return __no_error_line;
    }

    int tokenize(std::string text) {
        this->__token_list.clear();
        this->__line = {{ configure.boson_lexical_start_line }};
        int state = this->__start_state;
        std::string token_string;
        unsigned long index = 0;
        while (index < text.length()) {
            char character = text[index];
            index++;
            bool generate_token = false;
            if (this->_move_table_attribute.count(state)) {
                std::vector<int> &attribute_list = this->_move_table_attribute[state];
                std::vector<std::set<char>> &character_set_list = this->_move_table_character_set[state];
                std::vector<std::vector<std::vector<int>>> &state_range_list = this->_move_table_range_list[state];
                std::vector<int> &next_state_list = this->_move_table_next_state[state];
                unsigned long i;
                for (i = 0; i < attribute_list.size(); i++) {
                    int attribute = attribute_list[i];
                    std::set<char> &character_set = character_set_list[i];
                    std::vector<std::vector<int>> &range_list = state_range_list[i];
                    int next_state = next_state_list[i];
                    bool condition;
                    if (attribute == 2) {
                        condition = !character_set.count(character);
                        for (auto & range : range_list) {
                            condition &= character < range[0] || character > range[1];
                        }
                    } else {
                        condition = character_set.count(character);
                        if (attribute == 1 && this->__character_set.count(character) == 0) {
                            condition = true;
                        }
                        for (auto & range : range_list) {
                            if (condition || (range[0] <= character && character <= range[1])) {
                                condition = true;
                                break;
                            }
                        }
                    }
                    if (condition) {
                        if (this->__end_state_set.count(state) && !this->__end_state_set.count(next_state)) {
                            generate_token = true;
                            break;
                        }
                        token_string += character;
                        state = next_state;
                        break;
                    }
                }
                if (i == attribute_list.size()) {
                    if (this->__end_state_set.count(state)) {
                        generate_token = true;
                    } else {
                        this->__error_line = this->__line;
                        return this->__error_line;
                    }
                }
            } else {
                if (this->__end_state_set.count(state)) {
                    generate_token = true;
                } else {
                    this->__error_line = this->__line;
                    return this->__error_line;
                }
            }
            if (generate_token) {
                std::string symbol;
                if (this->__lexical_symbol_mapping.count(state)) {
                    symbol = this->__lexical_symbol_mapping[state];
                } else {
                    symbol = "{{ configure.boson_default_symbol }}";
                }
                bool is_token = this->_invoke_lexical_function(symbol, token_string);
                if (is_token) {
                    this->__token_list.emplace_back(token_string, this->__line, symbol);
                }
                token_string = "";
                state = this->__start_state;
                index--;
            }
        }
        if (this->__end_state_set.count(state)) {
            std::string symbol;
            if (this->__lexical_symbol_mapping.count(state)) {
                symbol = this->__lexical_symbol_mapping[state];
            } else {
                symbol = "{{ configure.boson_default_symbol }}";
            }
            bool is_token = this->_invoke_lexical_function(symbol, token_string);
            if (is_token) {
                this->__token_list.emplace_back(token_string, this->__line, symbol);
            }
        } else {
            throw std::runtime_error("Invalid state.");
        }
        this->__token_list.emplace_back("", this->__line, "{{ configure.boson_end_symbol }}");
        return this->__error_line;
    }

    void lexical_function_entity(std::string &function_name, lexical_function &function) {
        this->__lexical_function[function_name] = function;
    }

private:
    std::vector<{{ configure.boson_option['lexical_token_class_name'] }}> __token_list;
    int __line = {{ configure.boson_lexical_start_line }};
    int __error_line = {{ configure.boson_lexical_no_error_line }};
    int __no_error_line = {{ configure.boson_lexical_no_error_line }};
    std::unordered_map<int, std::vector<int>> _move_table_attribute = {
        {%- for state, state_move_table in lexical_package.compact_move_table.items() %}
        { {{- state }}, {
            {%- for each in state_move_table -%}
            {{ each[0] }}
            {%- if not loop.last %},{% endif -%}
            {%- endfor -%}
        }}
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };
    std::unordered_map<int, std::vector<std::set<char>>> _move_table_character_set = {
        {%- for state, state_move_table in lexical_package.compact_move_table.items() %}
        { {{- state }}, {
            {%- for each in state_move_table -%}
                { {%- for character in each[1] -%}
                    '{{ '\\x%s' % character.encode().hex() }}'
                {%- if not loop.last %},{% endif -%}
                {%- endfor -%}}
            {%- if not loop.last %},{% endif -%}
            {%- endfor -%}
        }}
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };
    std::unordered_map<int, std::vector<std::vector<std::vector<int>>>> _move_table_range_list = {
        {%- for state, state_move_table in lexical_package.compact_move_table.items() %}
        { {{- state }}, {
            {%- for each in state_move_table -%}
                { {%- for character_range in each[2] -%}
                    {'{{ '\\x%s' % character_range[0].encode().hex() }}', '{{ '\\x%s' % character_range[1].encode().hex() }}'}
                {%- if not loop.last %},{% endif -%}
                {%- endfor -%}}
            {%- if not loop.last %},{% endif -%}
            {%- endfor -%}
        }}
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };
    std::unordered_map<int, std::vector<int>> _move_table_next_state = {
        {%- for state, state_move_table in lexical_package.compact_move_table.items() %}
        { {{- state }}, {
            {%- for each in state_move_table -%}
            {{ each[3] }}
            {%- if not loop.last %},{% endif -%}
            {%- endfor -%}
        }}
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };
    std::set<char> __character_set = {
        {%- for character in lexical_package.character_set -%}
            '{{ '\\x%s' % character.encode().hex() }}'
        {%- if not loop.last %},{% endif -%}
        {%- endfor -%}
    };
    int __start_state = {{ lexical_package.start_state }};
    std::set<int> __end_state_set = {
        {%- for state in lexical_package.end_state_set -%}
            {{ state }}
        {%- if not loop.last %},{% endif -%}
        {%- endfor -%}
    };
    std::unordered_map<int, std::string> __lexical_symbol_mapping = {
        {%- for state, symbol in lexical_package.lexical_symbol_mapping.items() %}
        { {{- state }}, "{{ symbol }}"}
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };
    std::unordered_map<std::string, std::vector<std::string>> __symbol_function_mapping = {
        {%- for symbol, function_list in lexical_package.symbol_function_mapping.items() %}
        {"{{ symbol }}", {
            {%- for function in function_list -%}
            "{{ function }}"
            {%- if not loop.last %},{% endif -%}
            {%- endfor -%}
        }}
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };
    std::unordered_map<std::string, lexical_function> __lexical_function;

    bool _invoke_lexical_function(std::string &symbol, std::string &token_string) {
        bool is_token = true;
        if (this->__symbol_function_mapping.count(symbol)) {
            for (const auto& function : this->__symbol_function_mapping[symbol]) {
                if (this->__lexical_function.count(function)) {
                    is_token = this->__lexical_function[function](token_string);
                } else if (function == "skip") {
                    is_token = false;
                } else if (function == "newline") {
                    this->__line++;
                }
            }
        }
        return is_token;
    }
};


{% endif -%}

class {{ configure.boson_option['grammar_node_class_name'] }} {
public:
    {{ configure.boson_option['grammar_node_class_name'] }}() = default;

    explicit {{ configure.boson_option['grammar_node_class_name'] }}(std::string &text) {
        this->set_text(text);
    }

    int get_reduce_number() {
        return this->_reduce_number;
    }

    void set_reduce_number(int reduce_number) {
        this->_reduce_number = reduce_number;
    }

    std::string &get_text() {
        return this->_text;
    }

    void set_text(std::string &text) {
        this->_text = text;
    }

    void append(const {{ configure.boson_option['grammar_node_class_name'] }} &item) {
        this->_children.push_back(item);
    }

    void insert(int index, const {{ configure.boson_option['grammar_node_class_name'] }} &item) {
        this->_children.insert(this->_children.begin() + index, item);
    }

    std::vector<{{ configure.boson_option['grammar_node_class_name'] }}> &children() {
        return this->_children;
    }

    {{ configure.boson_option['grammar_node_class_name'] }} &operator[](int index) {
        return this->_children[index];
    }

private:
    int _reduce_number = -1;
    std::string _text;
    std::vector<{{ configure.boson_option['grammar_node_class_name'] }}> _children;
};


class {{ configure.boson_option['grammar_class_name'] }} {
public:
    {{ configure.boson_option['grammar_class_name'] }}() = default;

    {{ configure.boson_option['grammar_node_class_name'] }} &get_grammar_tree() {
        return this->_grammar_tree;
    }

    void set_grammar_tree({{ configure.boson_option['grammar_node_class_name'] }} &grammar_tree) {
        this->_grammar_tree = grammar_tree;
    }

    int get_error_index() {
        return this->_error_index;
    }

    void set_error_index(int error_index) {
        this->_error_index = error_index;
    }

private:
    {{ configure.boson_option['grammar_node_class_name'] }} _grammar_tree;
    int _error_index = -1;
};


{% if generate_semantics_analyzer -%}
template <class T>
class {{ configure.boson_option['semantics_node_class_name'] }} {
public:
    {{ configure.boson_option['semantics_node_class_name'] }}() = default;

    explicit {{ configure.boson_option['semantics_node_class_name'] }}(T data): _data(data) {};

    static {{ configure.boson_option['semantics_node_class_name'] }} &null_node() {
        static {{ configure.boson_option['semantics_node_class_name'] }} node;
        return node;
    }

    T &get_data() {
        return this->_data;
    }

    void set_data(T data) {
        this->_data = std::move(data);
    }

    int get_reduce_number() {
        return this->_reduce_number;
    }

    void set_reduce_number(int reduce_number) {
        this->_reduce_number = reduce_number;
    }

    const std::string &get_text() {
        return this->_text;
    }

    void set_text(std::string &text) {
        this->_text = text;
    }

    void append(const {{ configure.boson_option['semantics_node_class_name'] }} &item) {
        this->_children.push_back(item);
    }

    void insert(int index, const {{ configure.boson_option['semantics_node_class_name'] }} &item) {
        this->_children.insert(this->_children.begin() + index, item);
    }

    std::vector<{{ configure.boson_option['semantics_node_class_name'] }}> &children() {
        return this->_children;
    }

    {{ configure.boson_option['semantics_node_class_name'] }} &operator[](int index) {
        return this->_children[index];
    }

protected:
    int _reduce_number = -1;
    std::string _text;
    std::vector<{{ configure.boson_option['semantics_node_class_name'] }}> _children;
    T _data;
};


{% endif -%}
class {{ configure.boson_option['grammar_analyzer_class_name'] }} {
public:
    {{ configure.boson_option['grammar_analyzer_class_name'] }}() = default;

    {{ configure.boson_option['grammar_class_name'] }} grammar_analysis(std::vector<{{ configure.boson_option['lexical_token_class_name'] }}> token_list) {
        {{ configure.boson_option['grammar_class_name'] }} grammar;
        std::stack<int> analysis_stack;
        std::stack<{{ configure.boson_option['grammar_node_class_name'] }}> symbol_stack;
        analysis_stack.push(0);
        int token_index = 0;
        while (token_index < token_list.size()) {
            {{ configure.boson_option['lexical_token_class_name'] }} &token = token_list[token_index];
            int current_state = analysis_stack.top();
            {%- if sparse_table %}
            std::string operation = "{{ configure.boson_table_sign_error }}";
            int terminal_index = this->_terminal_index[token.symbol];
            if (this->_action_table.count(current_state)) {
                std::unordered_map<int, std::string> &actions = this->_action_table[current_state];
                if (actions.count(terminal_index)) {
                    operation = actions[terminal_index];
                }
            }
            {%- else %}
            std::string operation = this->_action_table[current_state][this->_terminal_index[token.symbol]];
            {%- endif %}
            char operation_flag = operation[0];
            if (operation_flag == '{{ configure.boson_table_sign_error }}') {
                grammar.set_error_index(token_index);
                return grammar;
            } else if (operation_flag == '{{ configure.boson_table_sign_shift }}') {
                int state_number = (int) strtol(operation.c_str() + 1, nullptr, 10);
                analysis_stack.push(state_number);
                token_index++;
                {{ configure.boson_option['grammar_node_class_name'] }} grammar_node(token.text);
                symbol_stack.push(grammar_node);
            } else if (operation_flag == '{{ configure.boson_table_sign_reduce }}') {
                int statement_index = (int) strtol(operation.c_str() + 1, nullptr, 10) - 1;
                int reduce_sum = this->_reduce_symbol_sum[statement_index];
                for (int i = 0; i < reduce_sum; i++) {
                    analysis_stack.pop();
                }
                current_state = analysis_stack.top();
                int current_non_terminal_index = this->_reduce_to_non_terminal_index[statement_index];
                {%- if sparse_table %}
                int goto_next_state = -1;
                if (this->_goto_table.count(current_state)) {
                    std::unordered_map<int, int> &goto_table = this->_goto_table[current_state];
                    if (goto_table.count(current_non_terminal_index)) {
                        goto_next_state = goto_table[current_non_terminal_index];
                    }
                }
                {%- else %}
                int goto_next_state = this->_goto_table[current_state][current_non_terminal_index];
                {%- endif %}
                if (goto_next_state == {{ configure.boson_invalid_goto }}) {
                    throw std::runtime_error("Invalid goto action.");
                }
                analysis_stack.push(goto_next_state);
                {%- if have_special_generate %}
                if (this->_node_table.count(statement_index)) {
                    std::vector<{{ configure.boson_option['grammar_node_class_name'] }}> symbol_package;
                    for (int i = 0; i < reduce_sum; i++) {
                        symbol_package.insert(symbol_package.begin(), symbol_stack.top());
                        symbol_stack.pop();
                    }
                    symbol_stack.push(this->_generate_grammar_tuple(statement_index, this->_node_table[statement_index], symbol_package));
                {%- endif %}
                {%- if have_default_reduce_tuple %}
                {%- if have_special_generate %}
                } else if (this->_none_grammar_tuple_reduce.count(statement_index)) {
                {%- else %}
                if (this->_none_grammar_tuple_reduce.count(statement_index)) {
                {%- endif %}
                    {{ configure.boson_option['grammar_node_class_name'] }} grammar_node;
                    for (int i = 0; i < reduce_sum; i++) {
                        grammar_node.insert(0, symbol_stack.top());
                        symbol_stack.pop();
                    }
                    grammar_node.set_reduce_number(statement_index);
                    symbol_stack.push(grammar_node);
                {%- endif %}
                {%- if have_special_generate or have_default_reduce_tuple %}
                } else {
                    throw std::runtime_error("Invalid reduce number.");
                }
                {%- endif %}
            } else if (operation_flag == '{{ configure.boson_table_sign_accept }}') {
                grammar.set_grammar_tree(symbol_stack.top());
                return grammar;
            } else {
                throw std::runtime_error("Invalid action.");
            }
        }
        throw std::runtime_error("Analyzer unusual exit.");
    }

private:
    std::unordered_map<std::string, int>_terminal_index = {
        {%- for terminal, index in analyzer_table.terminal_index.items() %}
        {"{{ terminal }}", {{ index -}} }
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };
    {% if sparse_table %}
    std::unordered_map<int, std::unordered_map<int, std::string>> _action_table = {
        {%- for i, sub_table in analyzer_table.action_table.items() %}
        { {{- i }}, {
        {%- for j, each in sub_table.items() -%}
        { {{- j }}, "{{ each }}"}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
        }}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor %}
    };

    std::unordered_map<int, std::unordered_map<int, int>> _goto_table = {
        {%- for i, sub_table in analyzer_table.goto_table.items() %}
        { {{- i }}, {
        {%- for j, each in sub_table.items() -%}
        { {{- j }}, {{ each -}} }
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
        }}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor %}
    };
    {% else %}
    std::vector<std::vector<std::string>> _action_table = {
        {%- for line in analyzer_table.action_table %}
        {
            {%- for each in line -%}
            "{{ each }}"
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        }
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };

    std::vector<std::vector<int>> _goto_table = {
        {%- for line in analyzer_table.goto_table %}
        {
            {%- for each in line -%}
            {{ each }}
            {%- if not loop.last %}, {% endif -%}
            {%- endfor -%}
        }
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };

    {%- endif %}
    std::unordered_map<int, std::string> _node_table = {
        {%- for sentence, grammar_tuple in grammar_package.grammar_tuple_map.items() %}
        { {{- analyzer_table.sentence_list.index(sentence) }}, "{{ grammar_tuple }}"}
        {%- if not loop.last %},{% endif -%}
        {%- endfor %}
    };

    std::vector<int> _reduce_symbol_sum = {
        {%- for index in analyzer_table.reduce_symbol_sum -%}
        {{ index }}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
    };

    std::vector<int> _reduce_to_non_terminal_index = {
        {%- for index in analyzer_table.reduce_to_non_terminal_index -%}
        {{ index }}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
    };

    std::set<int> _none_grammar_tuple_reduce = {
        {%- for index in none_grammar_tuple_reduce -%}
        {{ index }}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
    };

    {{ configure.boson_option['grammar_node_class_name'] }} _generate_grammar_tuple(int statement_index, std::string &node_tuple, std::vector<{{ configure.boson_option['grammar_node_class_name'] }}> &symbol_package) {
        {{ configure.boson_option['grammar_node_class_name'] }} grammar_node;
        int state = 0;
        int sub_start_index = -1;
        bool star = false;
        int parenthesis_count = 0;
        std::string number_text;
        for (size_t i = 1; i < node_tuple.length(); i++) {
            char c = node_tuple[i];
            if (state == 0) {
                if (c == '(') {
                    state = 2;
                } else if (c == '$') {
                    {{ configure.boson_option['grammar_node_class_name'] }} reduce_node;
                    reduce_node.set_reduce_number(statement_index);
                    grammar_node.append(reduce_node);
                } else if (c == '?') {
                    for (auto &node : symbol_package) {
                        grammar_node.append(node);
                    }
                } else if (c == '\'' || c == ',' || c == ' ' || c == ')') {
                    continue;
                } else if (c == '*') {
                    star = true;
                } else if ('0' <= c && c <= '9') {
                    number_text += c;
                    state = 1;
                } else {
                    throw std::runtime_error("Invalid grammar node.");
                }
            } else if (state == 1) {
                if ('0' <= c && c <= '9') {
                    number_text += c;
                } else {
                    i--;
                    int reduce_number = (int) strtol(number_text.c_str(), nullptr, 10);
                    if (star) {
                        for (auto &node : symbol_package[reduce_number].children()) {
                            grammar_node.append(node);
                        }
                    } else {
                        grammar_node.append(symbol_package[reduce_number]);
                    }
                    star = false;
                    number_text = "";
                    state = 0;
                }
            } else if (state == 2) {
                if (c == '*') {
                    star = true;
                } else if (c == '\'' || c == ',' || c == ' ') {
                    continue;
                } else if ('0' <= c && c <= '9') {
                    number_text += c;
                } else {
                    i--;
                    state = 3;
                }
            } else {
                if (c == '(') {
                    if (parenthesis_count == 0) {
                        sub_start_index = i;
                    }
                    parenthesis_count++;
                } else if (c == ')') {
                    parenthesis_count--;
                    if (parenthesis_count == 0) {
                        int reduce_number = (int) strtol(number_text.c_str(), nullptr, 10);
                        std::string sub_node_tuple = node_tuple.substr(sub_start_index, i - sub_start_index + 1);
                        for (auto &each: symbol_package[reduce_number].children()) {
                            {{ configure.boson_option['grammar_node_class_name'] }} sub_node = this->_generate_grammar_tuple(-1, sub_node_tuple, each.children());
                            if (star) {
                                for (auto &node : sub_node.children()) {
                                    grammar_node.append(node);
                                }
                            } else {
                                grammar_node.append(sub_node);
                            }
                        }
                        star = false;
                        number_text = "";
                        state = 0;
                    }
                }
            }
        }
        grammar_node.set_reduce_number(statement_index);
        return grammar_node;
    }
};


{%- if generate_semantics_analyzer %}


template <class T>
class {{ configure.boson_option['semantics_analyzer_class_name'] }} {
public:
    using semantic_function = std::function<{{ configure.boson_option['semantics_node_class_name'] }}<T>({{ configure.boson_option['semantics_node_class_name'] }}<T> &)>;

    {{ configure.boson_option['semantics_analyzer_class_name'] }}() = default;

    {{ configure.boson_option['semantics_node_class_name'] }}<T> semantics_analysis({{ configure.boson_option['grammar_node_class_name'] }} &grammar_tree) {
        return this->_semantics_analysis(grammar_tree);
    }

    static {{ configure.boson_option['semantics_node_class_name'] }}<T> default_semantics_entity({{ configure.boson_option['semantics_node_class_name'] }}<T> &semantics_node) {
        return semantics_node;
    }

    static {{ configure.boson_option['semantics_node_class_name'] }}<T> naive_semantics_entity({{ configure.boson_option['semantics_node_class_name'] }}<T> &semantics_node) {
        if (semantics_node.children().size() == 1) {
            return semantics_node[0];
        } else {
            return semantics_node;
        }
    }

    void semantics_entity(int reduce_number, semantic_function function) {
        std::string reduce_name = "{{ configure.boson_grammar_name_prefix }}" + std::to_string(reduce_number);
        this->semantics_entity(reduce_name, function);
    }

    void semantics_entity(const char *reduce_name, semantic_function function) {
        std::string reduce_name_string(reduce_name);
        this->semantics_entity(reduce_name_string, function);
    }

    void semantics_entity(std::string &reduce_name, semantic_function function) {
        this->_semantics_entity[reduce_name] = function;
    }

private:
    std::unordered_map<int, std::string> _reduce_number_to_grammar_name = {
        {%- for reduce_number, grammar_name in reduce_number_to_grammar_name.items() %}
        { {{- reduce_number }}, "{{ grammar_name }}"}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor %}
    };

    std::unordered_map<int, int> _reduce_number_to_grammar_number = {
        {%- for reduce_number, grammar_number in reduce_number_to_grammar_number.items() %}
        { {{- reduce_number }}, {{ grammar_number -}} }
        {%- if not loop.last %}, {% endif -%}
        {%- endfor %}
    };

    std::set<int> _naive_reduce_number = {
        {%- for reduce_number in naive_reduce_number -%}
        {{ reduce_number }}
        {%- if not loop.last %}, {% endif -%}
        {%- endfor -%}
    };

    std::unordered_map<std::string, semantic_function> _semantics_entity;

    {{ configure.boson_option['semantics_node_class_name'] }}<T> _semantics_analysis(BosonGrammarNode &grammar_tree) {
        std::string grammar_name;
        if (this->_reduce_number_to_grammar_name.count(grammar_tree.get_reduce_number())) {
            grammar_name = this->_reduce_number_to_grammar_name[grammar_tree.get_reduce_number()];
        } else if (this->_reduce_number_to_grammar_number.count(grammar_tree.get_reduce_number())) {
            grammar_name = "{{ configure.boson_grammar_name_prefix }}" + std::to_string(this->_reduce_number_to_grammar_number[grammar_tree.get_reduce_number()]);
        } else {
            grammar_name = "{{ configure.boson_grammar_name_prefix }}hidden";
        }
        {{ configure.boson_option['semantics_node_class_name'] }}<T> semantics_node;
        for (auto &node: grammar_tree.children()) {
            if (!node.children().empty()) {
                semantics_node.append(this->_semantics_analysis(node));
            } else {
                {{ configure.boson_option['semantics_node_class_name'] }}<T> temp_node;
                temp_node.set_reduce_number(node.get_reduce_number());
                temp_node.set_text(node.get_text());
                semantics_node.append(temp_node);
            }
        }
        if (this->_semantics_entity.count(grammar_name)) {
            return this->_semantics_entity[grammar_name](semantics_node);
        } else if (this->_naive_reduce_number.count(grammar_tree.get_reduce_number())) {
            return {{ configure.boson_option['semantics_analyzer_class_name'] }}::naive_semantics_entity(semantics_node);
        } else {
            return {{ configure.boson_option['semantics_analyzer_class_name'] }}::default_semantics_entity(semantics_node);
        }
    }
};
{%- endif %}

