%LexicalTokenClassName LexicalToken;
%GrammarAnalyzerClassName BosonGrammarAnalyzer;
%SemanticsAnalyzerClassName BosonSemanticsAnalyzer;
%GenerateSemanticsAnalyzer yes;
%CodeComment no;
%SparseTable yes;
%StartSymbol boson;

string = <".*[^\\]">;

name = <[_a-zA-Z][_a-zA-Z0-9]*>;

node = <$[0-9]+|$@|$$|$\?>;

command = <%[_a-zA-Z]+>;

comment = <#[^\r\n]*>;

skip = <[\ \t]+> @{!skip};

newline = <\n\r|\n> @{!skip !newline};

boson : statement+;

statement : command_statement
          | lexicon_statement
          | grammar_statement
          ;

command_statement : command (name | string)+ end = command($0, *$1($?));

lexicon_statement : name assign lexical_define end = lexical_define($0, $2);

lexical_define : lexicon_list
               | regular_expression [at brace_l lexical_function+ brace_r] = ($0, $1(*$2))
               ;

lexicon_list : lexicon (or lexicon)* = ($0, *$1($1));

lexicon : lexicon_body [at brace_l lexical_function+ brace_r] = ($0, $1(*$2));

lexicon_body : lexeme+ = (*$0);

lexeme : complex_lexeme
       | name [closure] = lexical_name_closure($0, *$1($?))
       ;

complex_lexeme : parentheses_l sub_lexeme parentheses_r [closure] = lexical_closure($1, *$3($?))
               | bracket_l sub_lexeme bracket_r = lexical_optional($1)
               ;

sub_lexeme : lexeme+ = (*$0)
           | lexeme (or lexeme)+ = lexical_select($0, *$1($1))
           ;

lexical_function : internal_function
                 | name
                 ;

grammar_statement : name reduce derivation_list end = reduce($0, $2);

derivation_list : derivation (or derivation)* = ($0, *$1($1));

derivation : derivation_body [assign [name] grammar_tuple] = ($0, *$1(*$1($?), $2));

derivation_body : element+ = (*$0)
                | null
                |
                ;

grammar_tuple : parentheses_l node_element (comma node_element)* parentheses_r = ($1, *$2($1));

node_element : [star] node [grammar_tuple] = grammar_node(*$0($?), $1, *$2($?));

element : complex_element
        | name [closure] = name_closure($0, *$1($?))
        | string = literal($0)
        ;

complex_element : parentheses_l sub_derivation parentheses_r [closure] = complex_closure($1, *$3($?))
                | bracket_l sub_derivation bracket_r = complex_optional($1)
                ;

sub_derivation : element+ = (*$0)
               | element (or element)+ = select($0, *$1($1))
               ;

closure: plus
       | star
       ;
