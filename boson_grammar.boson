%grammar_analyzer_class_name BosonEBNFAnalyzer;
%semantics_analyzer_class_name BosonSemanticsAnalyzer;
%generate_semantics_analyzer yes;
%code_comment no;
%sparse_table yes;
%start_symbol boson;

boson : statement+;

statement : command_statement
          | lexicon_statement
          | grammar_statement
          ;

command_statement : command (name | string)+ end = command($0, *$1($?));

lexicon_statement : name assign lexicon_list end = lexical_define($0, $2);

lexicon_list : lexicon (or lexicon)* = ($0, *$1($1));

lexicon : lexeme+ [brace_l name+ brace_r] = ($0, *$1($1));

lexeme : complex_lexeme
       | [except] (alphabet | string | name) [postfix] = (*$0($?), *$1($?), $2($?))
       ;

complex_lexeme : parentheses_l sub_lexeme parentheses_r [postfix] = lexical_closure($1, *$3($?))
               | bracket_l sub_lexeme bracket_r = lexical_optional($1)
               ;

sub_lexeme : lexeme+ = (*$0)
           | lexeme (or lexeme)+ = lexical_select($0, *$1($1))
           ;

postfix : closure [greedy] = ($0, *$1($?))
        | count
        ;

grammar_statement : name reduce derivation_list end = reduce($0, $2);

derivation_list : derivation (or derivation)* = ($0, *$1($1));

derivation : derivation_body [assign [name] grammar_tuple] = ($0, *$1(*$1($?), $2));

derivation_body : element+ = (*$0)
                | null
                |
                ;

grammar_tuple : parentheses_l node_element (comma node_element)* parentheses_r = ($1, *$2($1));

node_element : [star] node [grammar_tuple] = grammar_node(*$0($?), $1, *$2($?));

element : complex_element
        | name [closure] = name_closure($0, *$1($?))
        | string = literal($0)
        ;

complex_element : parentheses_l sub_derivation parentheses_r [closure] = complex_closure($1, *$3($?))
                | bracket_l sub_derivation bracket_r = complex_optional($1)
                ;

sub_derivation : element+ = (*$0)
               | element (or element)+ = select($0, *$1($1))
               ;

closure: plus
       | star
       ;
